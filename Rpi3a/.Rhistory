knitr::opts_chunk$set(echo = TRUE)
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- rand_unit(n=1, a=55797, c=0, m = 4294967296, seed = NULL)
## take some of the unifrom random draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- rand_unit(n=1, a=55797, c=0, m = 4294967296, seed = NULL)
## take some of the unifrom random draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- rand_unit(1)
## take some of the unifrom random draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- rand_unit(1)
## take some of the unifrom random draws
print(num_draws)
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
print(num_draws)
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
walker <- function() {
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
matrix(unif_rand_draws)
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
}
walker()
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
matrix(unif_rand_draws)
## make vectors to hold the x and y locations
## initialize with initial condition
## build a for loop to calculate the trajectory.
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector()
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2:])
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2:])
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- rand_unit(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2])
## initialize with initial condition
## build a for loop to calculate the trajectory.
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2])
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 2:Tmax)
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2])
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 2:Tmax) {
}
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2])
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 1:4) {
}
## the number of random draws -- this is the number of time steps
num_draws <- floor(rand_unit(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
angles <- 2*pi*unif_rand_draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
A <- matrix(unif_rand_draws)
## make vectors to hold the x and y locations
x <- is.vector(A[2])
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 1:4) {
}
## the number of random draws -- this is the number of time steps
num_draws <- floor(runif(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
angles <- 2*pi*unif_rand_draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
dx <- cos(angles)
dy <- sin(angles)
x <- num_draws + 1
y <- num_draws + 1
x[1] <- 0
y[1] <- 0
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 2:(num_draws + 1)) {
x[i] <- x[i-1] + dx[i-1]
y[i] <- y[i-1] + dy[i-1]
}
## the number of random draws -- this is the number of time steps
num_draws <- floor(runif(1) * 10)
## take some of the unifrom random draws
unif_rand_draws <- runif(4)
angles <- 2*pi*unif_rand_draws
## create a matrix to hold the x and y step sizes, based on the uniform draws
dx <- cos(angles)
dy <- sin(angles)
x <- num_draws + 1
y <- num_draws + 1
x[1] <- 0
y[1] <- 0
## initialize with initial condition
x0 <- 0
y0 <- 0
## build a for loop to calculate the trajectory.
for (i in 2:(num_draws + 1)) {
x[i] <- x[i-1] + dx[i-1]
y[i] <- y[i-1] + dy[i-1]
}
plot(x,y)
plot(x,y)
install.packages("latexpdf")
tinytex::install_tinytex()
